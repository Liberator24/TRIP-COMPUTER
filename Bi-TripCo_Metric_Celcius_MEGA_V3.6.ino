// Bi-TripCo by Nick Stavrou
// Bi-Fuel (LPG + Unleaded) Trip Computer
// Metric version
// Arduino UNO, 0.96" OLED display and DS3231 RTC module
// Release date: 29 Mar 2017
// Details can be found at www.instructables.com

// Libraries
//#include "PinChangeInterrupt.h" // enables the interrupts at the other pin except the ones at the digital pins 2 and 3 
#include <avr/sleep.h>          // enables the sleep function
#include <avr/power.h>          // power management
#include <EEPROMex.h>           // enables some special functions for writing to and reading from EEPROM 
#include <EEPROMVar.h>
#include <Wire.h>               // IIC LIBRARY
#include "RTClib.h"             // Real Time Clock Library
#include <math.h>               // enables complex math functions
#include <Adafruit_ST7735.h>  // Include Adafruit_ST7735 library to drive the display
#include <Adafruit_GFX.h>      
#include <OneWire.h>
#include <DallasTemperature.h>
     

#define OLED_RESET 4
//Adafruit_SSD1306 display(OLED_RESET);

// Declare pins for the display:
#define TFT_CS     30
#define TFT_RST    28  // You can also connect this to the Arduino reset in which case, set this #define pin to -1!
#define TFT_DC     26
// The rest of the pins are pre-selected as the default hardware SPI for Arduino Uno (SCK = 51 and SDA = 52)

#define GREENE 0xB767

Adafruit_ST7735 tft = Adafruit_ST7735(TFT_CS, TFT_DC, TFT_RST);

RTC_DS3231 rtc;

#define ONE_WIRE_BUS 22 
OneWire oneWire(ONE_WIRE_BUS);
DallasTemperature sensors(&oneWire);

// variables declaration
volatile float vss_pulse_distance;  // distance coefficient 0.0003816033; -- change this according to your measurements (km/pulse)
volatile float LPG_injector_flow;                         
volatile float unleadedFlow;            // gasoline injector flow coef. -- change this according to your measurements (litres/microseconds) = 0.00000001720

byte LPG1, LPG2, LPG3, LPG4, digitLPG, pos = 20;
byte un1, un2, un3, un4, digitun, posi = 20;
byte VSS1, VSS2, VSS3, VSS4, digitVSS, posit = 20;
volatile unsigned long last_speed_calculation_time;
volatile unsigned long last_fuel_calculation_time;
volatile unsigned long vss_pulses;
volatile float traveled_distance, traveled_distance2, traveled_distance3,speed, seconds_passed, avg_speed, distance_to_Unleadedstation;
volatile float used_LPG, used_LPG2, instant_LPG_consumption, avg_LPG_consumption, Unleaded_in_tank, Full_tank = 45;
volatile float used_Unleaded, used_Unleaded2, instant_unlead_consumption;
volatile float average_L_100km_Unlead;


volatile unsigned long unleadTime1=0, unleadTime2=0, unleadinj_Open_Duration=0;
volatile unsigned long LPG_injector_open_duration = 0, injTime1=0, injTime2=0;
int postemp;
int vss_pin = 2; // VSS signal input at digital pin 2 (INT0)
int LPG_pin = 3; // LPG injector signal input at digital pin 3 (INT1)
int ignition_pin = 18; // ignition signal input
int unleaded_pin = 19; // Unleaded injector signal input


boolean buttonState, buttonState2;
boolean lastButtonState2 = HIGH; 
long lastDebounceTime = 0, logohold, counter, counter2;
volatile boolean ignition = false;
boolean ignoreRelease = false;
boolean inst_disp = true;
byte menunumber = 0,  menunumbermax = 10;
int h=0, m=0, s, m1;
boolean timeRead = false, displaychange = true;
//float thermReading, sensors.getTempCByIndex(0);
boolean dots = true;




//int samples[NUMSAMPLES];
//int i=0;

const unsigned char leaf [] PROGMEM= {
0x00, 0x00, 0x07, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x07, 0xFF, 0xFF, 0x00, 0x3F, 0xFC, 0x1E,
0x00, 0xFF, 0x80, 0x1C, 0x01, 0xFC, 0x00, 0x3C, 0x07, 0xF0, 0x00, 0x38, 0x0F, 0xC0, 0x00, 0x38,
0x1F, 0x00, 0x00, 0x70, 0x1E, 0x00, 0x00, 0x70, 0x3C, 0x00, 0x80, 0x70, 0x38, 0x03, 0xC0, 0x70,
0x70, 0x07, 0xC0, 0x70, 0xF0, 0x1F, 0x80, 0x70, 0xF0, 0x1E, 0x00, 0x70, 0xE0, 0x3E, 0x00, 0x70,
0xE0, 0x78, 0x00, 0x70, 0xE0, 0xF0, 0x00, 0xF0, 0xE1, 0xE0, 0x00, 0xF0, 0xE3, 0xE0, 0x00, 0xE0,
0xE3, 0x80, 0x00, 0xE0, 0xE7, 0x80, 0x01, 0xE0, 0xEF, 0x00, 0x03, 0xE0, 0xEE, 0x00, 0x03, 0xC0,
0xFE, 0x00, 0x07, 0x80, 0x7C, 0x00, 0x1F, 0x00, 0x7C, 0x00, 0xFE, 0x00, 0x3D, 0xFF, 0xFC, 0x00,
0x39, 0xFF, 0xF0, 0x00, 0x70, 0xFE, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00
};

const unsigned char  dist_to_LPG [] PROGMEM= {
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xFF, 0xFE, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xFF, 0xFE, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xFF, 0xFE, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xC0, 0x0E, 0x20,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xC0, 0x0E, 0x70,
0x00, 0x00, 0x3F, 0xFF, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xC0, 0x0E, 0x38,
0x00, 0x01, 0xFF, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xC0, 0x0E, 0x1C,
0x00, 0x0F, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xC0, 0x0E, 0x0C,
0x00, 0x3F, 0xFF, 0xFF, 0xFF, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xC0, 0x0F, 0x8C,
0x1F, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xC0, 0x0F, 0x8C,
0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xC0, 0x0F, 0x8C,
0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xFF, 0xFF, 0x8C,
0x1F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x60, 0x06, 0x00, 0x01, 0xFF, 0xFF, 0x8C,
0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE0, 0x00, 0x78, 0x07, 0x80, 0x01, 0xFF, 0xFF, 0x8C,
0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF8, 0x00, 0x1E, 0x01, 0xE0, 0x01, 0xFF, 0xFF, 0x8C,
0x7F, 0xE0, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0xFC, 0x00, 0x07, 0x80, 0x78, 0x01, 0xFF, 0xFF, 0x8C,
0x7F, 0xCF, 0x3F, 0xFF, 0xFF, 0xFE, 0x79, 0xFE, 0x00, 0x01, 0xE0, 0x1E, 0x01, 0xFF, 0xFF, 0x8C,
0x7F, 0x9F, 0xBF, 0xFF, 0xFF, 0xFC, 0xFD, 0xFE, 0x00, 0x00, 0x60, 0x06, 0x01, 0xFF, 0xFF, 0x8C,
0x3F, 0xBF, 0xDF, 0xFF, 0xFF, 0xFD, 0xFE, 0xFC, 0x00, 0x01, 0xE0, 0x1E, 0x01, 0xFF, 0xFF, 0x8C,
0x3F, 0x3F, 0xDF, 0xFF, 0xFF, 0xF9, 0xFE, 0xFC, 0x00, 0x07, 0x80, 0x78, 0x01, 0xFF, 0xFF, 0x8C,
0x0F, 0x7F, 0xDF, 0xFF, 0xFF, 0xFB, 0xFE, 0xFC, 0x00, 0x1E, 0x01, 0xE0, 0x01, 0xFF, 0xFF, 0x8C,
0x00, 0x3F, 0xCF, 0xFF, 0xFF, 0xF9, 0xFE, 0x70, 0x00, 0x78, 0x07, 0x80, 0x01, 0xFF, 0xFF, 0x8C,
0x00, 0x3F, 0xC0, 0x00, 0x00, 0x01, 0xFE, 0x00, 0x00, 0x60, 0x06, 0x00, 0x01, 0xFF, 0xFF, 0x8C,
0x00, 0x1F, 0x80, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xFF, 0xFF, 0x8C,
0x00, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xFF, 0xFE, 0xFC,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xFF, 0xFE, 0xF8,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xFF, 0xFE, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xFF, 0xFE, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xFF, 0xC0,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xFF, 0xC0,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xFF, 0xC0,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xFF, 0xC0
};

const unsigned char  average [] PROGMEM= {
0x00, 0x00, 0x07, 0xCE, 0x1F, 0xFE, 0x3F, 0xFE, 0x7C, 0x7C, 0x70, 0xFC, 0xF1, 0xFE, 0xE3, 0xEE,
0xE7, 0xCE, 0xEF, 0x8E, 0xFF, 0x1E, 0x7E, 0x1C, 0x7C, 0x7C, 0xFF, 0xF8, 0xFF, 0xF0, 0xE7, 0xC0
};

const unsigned char averagecons [] PROGMEM= {
0x00, 0x00, 0x01, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x07, 0xCE, 0x01, 0xFF, 0xFE, 0x00, 0x00, 0x00,
0x1F, 0xFE, 0x01, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x3F, 0xFE, 0x01, 0xC0, 0x0E, 0x20, 0x00, 0x00,
0x7C, 0x7C, 0x01, 0xC0, 0x0E, 0x70, 0x00, 0x00, 0x70, 0xFC, 0x01, 0xC0, 0x0E, 0x38, 0x00, 0x00,
0xF1, 0xFE, 0x01, 0xC0, 0x0E, 0x1C, 0x00, 0x00, 0xE3, 0xEE, 0x01, 0xC0, 0x0E, 0x0C, 0x00, 0x00,
0xE7, 0xCE, 0x01, 0xC0, 0x0F, 0x8C, 0x00, 0x00, 0xEF, 0x8E, 0x01, 0xC0, 0x0F, 0x8C, 0x00, 0x00,
0xFF, 0x1E, 0x01, 0xC0, 0x0F, 0x8C, 0x00, 0x00, 0x7E, 0x1C, 0x01, 0xFF, 0xFF, 0x8C, 0x00, 0x00,
0x7C, 0x7C, 0x01, 0xFF, 0xFF, 0x8C, 0x00, 0x00, 0xFF, 0xF8, 0x01, 0xFF, 0xFF, 0x8C, 0x00, 0x00,
0xFF, 0xF0, 0x01, 0xFF, 0xFF, 0x8C, 0x00, 0x00, 0xE7, 0xC0, 0x01, 0xFF, 0xFF, 0x8C, 0x00, 0x00,
0x00, 0x00, 0x01, 0xFF, 0xFF, 0x8C, 0x00, 0x00, 0x00, 0x00, 0x01, 0xFF, 0xFF, 0x8C, 0x00, 0x00,
0x00, 0x00, 0x01, 0xFF, 0xFF, 0x8C, 0x00, 0x00, 0x00, 0x00, 0x01, 0xFF, 0xFF, 0x8C, 0x00, 0x00,
0x00, 0x00, 0x01, 0xFF, 0xFF, 0x8C, 0x00, 0x00, 0x00, 0x00, 0x01, 0xFF, 0xFF, 0x8C, 0x00, 0x00,
0x00, 0x00, 0x01, 0xFF, 0xFF, 0x8C, 0x00, 0x00, 0x00, 0x00, 0x01, 0xFF, 0xFF, 0x8C, 0x00, 0x00,
0x00, 0x00, 0x01, 0xFF, 0xFE, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x01, 0xFF, 0xFE, 0xF8, 0x00, 0x00,
0x00, 0x00, 0x01, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xFF, 0xFE, 0x00, 0x00, 0x00,
0x00, 0x00, 0x0F, 0xFF, 0xFF, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xFF, 0xC0, 0x00, 0x00,
0x00, 0x00, 0x0F, 0xFF, 0xFF, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xFF, 0xC0, 0x00, 0x00
};
const unsigned char avspeed [] PROGMEM = {
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x01, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0xFF, 0x80, 0x00, 0x00,
0x00, 0x00, 0x00, 0x3F, 0xFF, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x6F, 0xF0, 0x00, 0x00,
0x00, 0x00, 0x01, 0xF0, 0x60, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x03, 0xC0, 0x60, 0x3C, 0x00, 0x00,
0x07, 0xCE, 0x07, 0x80, 0x60, 0x3E, 0x00, 0x00, 0x1F, 0xFE, 0x0F, 0x00, 0x00, 0x7F, 0x00, 0x00,
0x3F, 0xFE, 0x0E, 0x30, 0x00, 0xE7, 0x00, 0x00, 0x7C, 0x7C, 0x1E, 0x38, 0x00, 0xC7, 0x80, 0x00,
0x70, 0xFC, 0x1C, 0x1E, 0x00, 0x03, 0x80, 0x00, 0xF1, 0xFE, 0x1C, 0x0F, 0x00, 0x03, 0x80, 0x00,
0xE3, 0xEE, 0x3C, 0x0F, 0xC0, 0x03, 0xC0, 0x00, 0xE7, 0xCE, 0x38, 0x07, 0xF0, 0x01, 0xC0, 0x00,
0xEF, 0x8E, 0x38, 0x03, 0xF8, 0x01, 0xC0, 0x00, 0xFF, 0x1E, 0x3F, 0x03, 0xF8, 0x0F, 0xC0, 0x00,
0x7E, 0x1C, 0x3F, 0x01, 0xF8, 0x0F, 0xC0, 0x00, 0x7C, 0x7C, 0x38, 0x01, 0xF0, 0x01, 0xC0, 0x00,
0xFF, 0xF8, 0x38, 0x00, 0xE0, 0x01, 0xC0, 0x00, 0xFF, 0xF0, 0x3C, 0x00, 0x00, 0x03, 0xC0, 0x00,
0xE7, 0xC0, 0x1C, 0x00, 0x00, 0x03, 0x80, 0x00, 0x00, 0x00, 0x1C, 0x00, 0x00, 0x03, 0x80, 0x00,
0x00, 0x00, 0x1E, 0x30, 0x00, 0xC7, 0x80, 0x00, 0x00, 0x00, 0x0E, 0x70, 0x00, 0xE7, 0x00, 0x00,
0x00, 0x00, 0x0F, 0xE0, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x07, 0xFF, 0xFF, 0xFE, 0x00, 0x00,
0x00, 0x00, 0x03, 0xFF, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
const unsigned char dist [] PROGMEM= {
0x00, 0x39, 0x9C, 0x00, 0x00, 0x39, 0x9C, 0x00, 0x00, 0x71, 0x8E, 0x00, 0x00, 0x71, 0x8E, 0x00,
0x00, 0x71, 0x8E, 0x00, 0x00, 0xE0, 0x07, 0x00, 0x00, 0xE0, 0x07, 0x00, 0x00, 0xE1, 0x87, 0x00,
0x01, 0xC1, 0x83, 0x80, 0x01, 0xC1, 0x83, 0x80, 0x01, 0xC1, 0x83, 0x80, 0x03, 0x81, 0x81, 0xC0,
0x03, 0x81, 0x81, 0xC0, 0x03, 0x81, 0x81, 0xC0, 0x07, 0x00, 0x00, 0xE0, 0x07, 0x00, 0x00, 0xE0,
0x07, 0x01, 0x80, 0xE0, 0x0E, 0x01, 0x80, 0x70, 0x0E, 0x01, 0x80, 0x70, 0x0E, 0x01, 0x80, 0x70,
0x1C, 0x01, 0x80, 0x38, 0x1C, 0x01, 0x80, 0x38, 0x1C, 0x01, 0x80, 0x38, 0x38, 0x00, 0x00, 0x1C,
0x38, 0x00, 0x00, 0x1C, 0x38, 0x01, 0x80, 0x1C, 0x70, 0x01, 0x80, 0x0E, 0x70, 0x01, 0x80, 0x0E,
0x70, 0x01, 0x80, 0x0E, 0xE0, 0x01, 0x80, 0x07, 0xE0, 0x01, 0x80, 0x07, 0xE0, 0x01, 0x80, 0x07
};
const unsigned char Unleaded_fill_nozzle [] PROGMEM= { 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x07, 0xC0, 0x00, 0x00, 0x1F, 0xF0, 0x00,
0x00, 0x1F, 0xFF, 0xE0, 0x00, 0x1F, 0xFF, 0xF0, 0x00, 0x3F, 0xF8, 0x18, 0x00, 0x71, 0xF0, 0x00,
0x00, 0xEF, 0xE0, 0x00, 0x01, 0xD1, 0xC0, 0x08, 0x07, 0xE1, 0x80, 0x08, 0x07, 0x82, 0x00, 0x1C,
0x0E, 0xC6, 0x00, 0x1C, 0x18, 0x6C, 0x00, 0x3E, 0x10, 0x38, 0x00, 0x3E, 0x30, 0x00, 0x00, 0x1E,
0x30, 0x00, 0x00, 0x08, 0x30, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00,
0x30, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00,
0x10, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

const unsigned char  logo [] PROGMEM= {
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x3F, 0xFF, 0xFF, 0xFF, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0xFF, 0xFF,
0xFF, 0xFF, 0xFF, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0xFF, 0x80, 0x00, 0x00, 0x00, 0x00, 0x1F, 0xFF, 0xFF, 0x80, 0x00, 0x01, 0xFF, 0xFF, 0xF0, 0x00,
0x00, 0x00, 0x00, 0x3F, 0xFF, 0xC0, 0x00, 0x00, 0x00, 0x07, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0x00,
0x7F, 0x9F, 0xC0, 0x00, 0x00, 0x00, 0x07, 0xF3, 0xFE, 0x00, 0x00, 0x00, 0x01, 0xFC, 0x0F, 0xE0,
0x00, 0x00, 0x00, 0x07, 0xF0, 0x7F, 0x00, 0x00, 0x00, 0x01, 0xF8, 0x0F, 0xE0, 0x00, 0x00, 0x00,
0x0F, 0xF0, 0x3F, 0x00, 0x00, 0x00, 0x03, 0xF0, 0x0F, 0xE0, 0x00, 0x00, 0x00, 0x0F, 0xF0, 0x1F,
0x80, 0x00, 0x00, 0x03, 0xE0, 0x0F, 0xE0, 0x00, 0x00, 0x00, 0x0F, 0xF0, 0x0F, 0xC0, 0x00, 0x00,
0x07, 0xE0, 0x0F, 0xF0, 0x00, 0x00, 0x00, 0x1F, 0xF0, 0x07, 0xC0, 0x00, 0x00, 0x07, 0xC0, 0x0F,
0xF0, 0x00, 0x00, 0x00, 0x1F, 0xF0, 0x07, 0xC0, 0x00, 0x00, 0x07, 0xC0, 0x0F, 0xF0, 0x00, 0x00,
0x00, 0x1F, 0xF0, 0x07, 0xC0, 0x00, 0x00, 0x07, 0xC0, 0x0F, 0xF8, 0x00, 0x00, 0x00, 0x1F, 0xF0,
0x03, 0xE0, 0x00, 0x00, 0x0F, 0x80, 0x0F, 0xF8, 0x00, 0x00, 0x00, 0x3F, 0xF0, 0x03, 0xE0, 0x00,
0x00, 0x0F, 0x80, 0x0F, 0xF8, 0x00, 0x00, 0x00, 0x3F, 0xF0, 0x03, 0xE0, 0x00, 0x00, 0x0F, 0x80,
0x0F, 0xF8, 0x00, 0x00, 0x00, 0x3F, 0xF0, 0x03, 0xE0, 0x00, 0x00, 0x0F, 0x80, 0x0F, 0xFC, 0x00,
0x00, 0x00, 0x3F, 0xE0, 0x03, 0xE0, 0x00, 0x00, 0x0F, 0x80, 0x0F, 0xFC, 0x00, 0x00, 0x00, 0x7F,
0xE0, 0x03, 0xE0, 0x00, 0x00, 0x0F, 0x80, 0x0F, 0xFC, 0x00, 0x00, 0x00, 0x7F, 0xE0, 0x03, 0xE0,
0x00, 0x00, 0x0F, 0x80, 0x0F, 0xFC, 0x00, 0x00, 0x00, 0x7F, 0xE0, 0x03, 0xE0, 0x00, 0x00, 0x0F,
0x80, 0x0F, 0xFE, 0x00, 0x00, 0x00, 0x7F, 0xE0, 0x03, 0xE0, 0x00, 0x00, 0x0F, 0x80, 0x0F, 0xFE,
0x00, 0x00, 0x00, 0xFF, 0xE0, 0x03, 0xE0, 0x00, 0x00, 0x0F, 0x80, 0x0F, 0xFE, 0x00, 0x00, 0x00,
0xFF, 0xE0, 0x03, 0xE0, 0x00, 0x00, 0x0F, 0x80, 0x0F, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0xE0, 0x03,
0xE0, 0x00, 0x00, 0x0F, 0x80, 0x0F, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0xE0, 0x03, 0xE0, 0x00, 0x00,
0x0F, 0x80, 0x0F, 0xFF, 0x00, 0x00, 0x01, 0xFF, 0xE0, 0x03, 0xE0, 0x00, 0x00, 0x0F, 0x80, 0x0F,
0xFF, 0x00, 0x00, 0x01, 0xFF, 0xE0, 0x03, 0xE0, 0x00, 0x00, 0x0F, 0x80, 0x0F, 0xFF, 0x80, 0x00,
0x01, 0xFF, 0xE0, 0x03, 0xE0, 0x00, 0x00, 0x0F, 0x80, 0x07, 0xFF, 0x80, 0x00, 0x03, 0xFF, 0xE0,
0x03, 0xE0, 0x00, 0x00, 0x0F, 0x80, 0x07, 0xFF, 0x80, 0x00, 0x03, 0xFF, 0xE0, 0x03, 0xE0, 0x00,
0x00, 0x0F, 0x80, 0x07, 0xFF, 0xC0, 0x00, 0x07, 0xFF, 0xE0, 0x03, 0xE0, 0x00, 0x00, 0x0F, 0x80,
0x07, 0xFF, 0xC0, 0x00, 0x07, 0xFF, 0xE0, 0x03, 0xE0, 0x00, 0x00, 0x0F, 0x80, 0x07, 0xFF, 0xE0,
0x00, 0x0F, 0xFF, 0xE0, 0x03, 0xE0, 0x00, 0x00, 0x0F, 0x80, 0x07, 0xFF, 0xF0, 0x00, 0x0F, 0xFF,
0xC0, 0x03, 0xE0, 0x00, 0x00, 0x0F, 0x80, 0x07, 0xFF, 0xF8, 0x00, 0x1F, 0xFF, 0xC0, 0x03, 0xE0,
0x00, 0x00, 0x0F, 0x80, 0x07, 0xFF, 0xFC, 0x00, 0x7F, 0xFF, 0xC0, 0x03, 0xE0, 0x00, 0x00, 0x0F,
0x80, 0x07, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC0, 0x03, 0xE0, 0x00, 0x00, 0x07, 0xC0, 0x07, 0xFF,
0xFF, 0xFF, 0xFF, 0xFF, 0xC0, 0x03, 0xE0, 0x00, 0x00, 0x07, 0xC0, 0x07, 0xFF, 0xFF, 0xFF, 0xFF,
0xFF, 0xC0, 0x03, 0xE0, 0x00, 0x00, 0x07, 0xC0, 0x07, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC0, 0x03,
0xC0, 0x00, 0x00, 0x07, 0xC0, 0x07, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC0, 0x07, 0xC0, 0x00, 0x00,
0x07, 0xC0, 0x03, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC0, 0x07, 0xC0, 0x00, 0x00, 0x07, 0xC0, 0x03,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC0, 0x07, 0xC0, 0x00, 0x00, 0x07, 0xC0, 0x03, 0xFF, 0xFF, 0xFF,
0xFF, 0xFF, 0xC0, 0x07, 0xC0, 0x00, 0x00, 0x03, 0xC0, 0x03, 0xFF, 0xFF, 0x83, 0xFF, 0xFF, 0x80,
0x07, 0xC0, 0x00, 0x00, 0x03, 0xE0, 0x03, 0xFF, 0xF8, 0x00, 0x1F, 0xFF, 0x80, 0x07, 0xC0, 0x00,
0x00, 0x03, 0xE0, 0x03, 0xFF, 0xF0, 0x00, 0x0F, 0xFF, 0x80, 0x0F, 0x80, 0x00, 0x00, 0x03, 0xE0,
0x03, 0xFF, 0xE0, 0x00, 0x0F, 0xFF, 0x80, 0x0F, 0x80, 0x00, 0x00, 0x03, 0xE0, 0x03, 0xFF, 0xE0,
0x00, 0x0F, 0xFF, 0x80, 0x0F, 0x80, 0x00, 0x00, 0x01, 0xF0, 0x03, 0xFF, 0xE0, 0x00, 0x07, 0xFF,
0x80, 0x0F, 0x80, 0x00, 0x00, 0x01, 0xF0, 0x01, 0xFF, 0xC0, 0x00, 0x07, 0xFF, 0x80, 0x1F, 0x00,
0x00, 0x00, 0x01, 0xF0, 0x01, 0xFF, 0xC0, 0x00, 0x07, 0xFF, 0x80, 0x1F, 0x00, 0x00, 0x00, 0x00,
0xF8, 0x01, 0xFF, 0xC0, 0x00, 0x03, 0xFF, 0x80, 0x3F, 0x00, 0x00, 0x00, 0x00, 0xFC, 0x01, 0xFF,
0x80, 0x00, 0x03, 0xFF, 0x00, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x7E, 0x01, 0xFF, 0x80, 0x00, 0x03,
0xFF, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00, 0x7F, 0x01, 0xFF, 0x80, 0x00, 0x01, 0xFF, 0x01, 0xFC,
0x00, 0x00, 0x00, 0x00, 0x3F, 0xC1, 0xFF, 0x00, 0x00, 0x01, 0xFF, 0x07, 0xF8, 0x00, 0x00, 0x00,
0x00, 0x1F, 0xF9, 0xFF, 0x00, 0x00, 0x01, 0xFF, 0x9F, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x07, 0xFF,
0xFF, 0x00, 0x00, 0x01, 0xFF, 0xFF, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x03, 0xFF, 0xFF, 0xFF, 0xFF,
0xFF, 0xFF, 0xFF, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC0, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0xC7,
0xFC, 0x3F, 0xFC, 0x3F, 0xE1, 0xFD, 0xFF, 0xFC, 0x07, 0xFE, 0x00, 0x3F, 0x87, 0xF8, 0xFF, 0xFE,
0x3F, 0xF1, 0xF8, 0xFF, 0xFF, 0x03, 0xFF, 0x00, 0x1F, 0x01, 0xF1, 0xF8, 0x1F, 0x0F, 0xF0, 0x70,
0x7C, 0x1F, 0x80, 0xFF, 0x00, 0x1F, 0x01, 0xF1, 0xF0, 0x0F, 0x8F, 0xF8, 0x70, 0x7C, 0x0F, 0xC1,
0xCF, 0x80, 0x1F, 0xFF, 0xF1, 0xF0, 0x0F, 0x8E, 0xFC, 0x70, 0x7C, 0x07, 0xC3, 0x8F, 0xC0, 0x1F,
0xFF, 0xF3, 0xF0, 0x0F, 0x8E, 0x7E, 0x70, 0x7C, 0x07, 0xC3, 0x87, 0xC0, 0x1F, 0xFF, 0xF3, 0xF0,
0x0F, 0x8E, 0x3F, 0x70, 0x7C, 0x07, 0xC7, 0xFF, 0xE0, 0x1F, 0x01, 0xF1, 0xF0, 0x0F, 0x8E, 0x3F,
0x70, 0x7C, 0x07, 0xC7, 0xFF, 0xF0, 0x1F, 0x01, 0xF1, 0xF8, 0x1F, 0x0E, 0x1F, 0xF0, 0x7C, 0x0F,
0x8E, 0x01, 0xF0, 0x1F, 0x01, 0xF0, 0xFE, 0x7F, 0x0E, 0x0F, 0xF0, 0x7F, 0xFF, 0x1E, 0x01, 0xF8,
0x7F, 0xC7, 0xFC, 0x3F, 0xFC, 0x3F, 0x87, 0xF1, 0xFF, 0xFE, 0x7F, 0x87, 0xFE, 0x00, 0x00, 0x00,
0x07, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
};

const unsigned char FuelTank [] PROGMEM = {
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x80,
0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF8,
0x7E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFC, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1E,
0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0E, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0E,
0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0E, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0E,
0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0E, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0E,
0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0E, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0E,
0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0E, 0xEF, 0x00, 0x01, 0xE0, 0x00, 0x3C, 0x00, 0x0E,
0xFF, 0xF0, 0x07, 0xFE, 0x00, 0xFF, 0xC0, 0x1E, 0xFF, 0xFC, 0x0F, 0xFF, 0x81, 0xFF, 0xF0, 0x3E,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC,
0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF8, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE0,
0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

const unsigned char petrolstationpump [] PROGMEM = {
0x03, 0xFF, 0xFC, 0x00, 0x03, 0xFF, 0xFC, 0x00, 0x03, 0xFF, 0xFC, 0x00, 0x03, 0x80, 0x1C, 0x40,
0x03, 0x80, 0x1C, 0xE0, 0x03, 0x80, 0x1C, 0x70, 0x03, 0x80, 0x1C, 0x38, 0x03, 0x80, 0x1C, 0x18,
0x03, 0x80, 0x1F, 0x18, 0x03, 0x80, 0x1F, 0x18, 0x03, 0x80, 0x1F, 0x18, 0x03, 0xFF, 0xFF, 0x18,
0x03, 0xFF, 0xFF, 0x18, 0x03, 0xFF, 0xFF, 0x18, 0x03, 0xFF, 0xFF, 0x18, 0x03, 0xFF, 0xFF, 0x18,
0x03, 0xFF, 0xFF, 0x18, 0x03, 0xFF, 0xFF, 0x18, 0x03, 0xFF, 0xFF, 0x18, 0x03, 0xFF, 0xFF, 0x18,
0x03, 0xFF, 0xFF, 0x18, 0x03, 0xFF, 0xFF, 0x18, 0x03, 0xFF, 0xFF, 0x18, 0x03, 0xFF, 0xFF, 0x18,
0x03, 0xFF, 0xFD, 0xF8, 0x03, 0xFF, 0xFD, 0xF0, 0x03, 0xFF, 0xFC, 0x00, 0x03, 0xFF, 0xFC, 0x00,
0x1F, 0xFF, 0xFF, 0x80, 0x1F, 0xFF, 0xFF, 0x80, 0x1F, 0xFF, 0xFF, 0x80, 0x1F, 0xFF, 0xFF, 0x80
};

const unsigned char speedometer [] PROGMEM = {
0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xE0, 0x00, 0x00, 0x7F, 0xFE, 0x00, 0x00, 0xFF, 0xFF, 0x00,
0x03, 0xFD, 0xBF, 0xC0, 0x07, 0xC1, 0x83, 0xE0, 0x0F, 0x01, 0x80, 0xF0, 0x1E, 0x01, 0x80, 0xF8,
0x3C, 0x00, 0x01, 0xFC, 0x38, 0xC0, 0x03, 0x9C, 0x78, 0xE0, 0x03, 0x1E, 0x70, 0x78, 0x00, 0x0E,
0x70, 0x3C, 0x00, 0x0E, 0xF0, 0x3F, 0x00, 0x0F, 0xE0, 0x1F, 0xC0, 0x07, 0xE0, 0x0F, 0xE0, 0x07,
0xFC, 0x0F, 0xE0, 0x3F, 0xFC, 0x07, 0xE0, 0x3F, 0xE0, 0x07, 0xC0, 0x07, 0xE0, 0x03, 0x80, 0x07,
0xF0, 0x00, 0x00, 0x0F, 0x70, 0x00, 0x00, 0x0E, 0x70, 0x00, 0x00, 0x0E, 0x78, 0xC0, 0x03, 0x1E,
0x39, 0xC0, 0x03, 0x9C, 0x3F, 0x80, 0x01, 0xFC, 0x1F, 0xFF, 0xFF, 0xF8, 0x0F, 0xFF, 0xFF, 0xF0,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

const unsigned char snowflake [] PROGMEM = {
0x01, 0x80, 0x07, 0xE0, 0x13, 0xC8, 0xD1, 0x8B, 0xF9, 0x9F, 0x39, 0x9C, 0xFF, 0xFF, 0x07, 0xE0,
0x07, 0xE0, 0xFF, 0xFF, 0x39, 0x9C, 0xF9, 0x9F, 0xD1, 0x8B, 0x13, 0xC8, 0x07, 0xE0, 0x01, 0x80
};

void setup()
{ 

   // start serial port 
 Serial.begin(9600); 
 sensors.begin(); 
 
  
 
 // Display setup:

  // Use this initializer if you're using a 1.8" TFT
  tft.initR(INITR_BLACKTAB);  // Initialize a ST7735S chip, black tab
  tft.setRotation(1);
  tft.setTextWrap(false);  // By default, long lines of text are set to automatically “wrap” back to the leftmost column.
                           // To override this behavior (so text will run off the right side of the display - useful for
                           // scrolling marquee effects), use setTextWrap(false). The normal wrapping behavior is restored
                           // with setTextWrap(true).
  
  
  pinMode(24, OUTPUT); //wygaszenie podświetlenia
  pinMode(34, INPUT); // Button 2
  pinMode(32, INPUT); // Button 1
  
  pinMode(vss_pin, INPUT);
  pinMode(LPG_pin, INPUT);
  pinMode(ignition_pin, INPUT);
  pinMode(unleaded_pin, INPUT);

  // below recalls the values stored in case of power loss 
  traveled_distance = EEPROM.readFloat(0);
  traveled_distance2 = EEPROM.readFloat (5);
  used_LPG = EEPROM.readFloat (10);
  used_LPG2 = EEPROM.readFloat(15);
  Unleaded_in_tank = EEPROM.readFloat(20);
  seconds_passed = EEPROM.readFloat(25);
  used_Unleaded = EEPROM.readFloat(30);
  traveled_distance3 = EEPROM.readFloat (35);
  used_Unleaded2 = EEPROM.readFloat(45);
  LPG1 = EEPROM.readByte (40);
  LPG2 = EEPROM.readByte (41);
  LPG3 = EEPROM.readByte (42);
  LPG4 = EEPROM.readByte (43);
  LPG_injector_flow = (LPG1 * 1000 + LPG2 * 100 + LPG3 * 10 + LPG4) * 1e-11;
// unleaded
  un1 = EEPROM.readByte (50);
  un2 = EEPROM.readByte (51);
  un3 = EEPROM.readByte (52);
  un4 = EEPROM.readByte (53);
  unleadedFlow = (un1 * 1000 + un2 * 100 + un3 * 10 + un4) * 1e-11;
  // vss_pulse_distance
  VSS1 = EEPROM.readByte (55);
  VSS2 = EEPROM.readByte (56);
  VSS3 = EEPROM.readByte (57);
  VSS4 = EEPROM.readByte (58);
  vss_pulse_distance = (VSS1 * 1000 + VSS2 * 100 + VSS3 * 10 + VSS4) * 1e-7;
  
  noInterrupts(); 
  //set and initialize the TIMER1 

    TCCR1A = 0;            // undo the Arduino's timer configuration
    TCCR1B = 0;            // ditto
    TCNT1  = 0;            // reset timer
    OCR1A  = 62500 - 1;    // period = 62500 clock tics
    TCCR1B = _BV(WGM12)    // CTC mode, TOP = OCR1A
           | _BV(CS12);    // clock at F_CPU/256
    TIMSK1 = _BV(OCIE1A);  // interrupt on output compare A

  
  
  attachInterrupt(digitalPinToInterrupt(ignition_pin), ignitionSignal, CHANGE);
  last_speed_calculation_time = millis();
  last_fuel_calculation_time = millis();
  interrupts();
  delay(10);
}

void loop()

  {// When the ignition switch is turned, executes the next two ifs 

 //Serial.println(speed);
 Serial.println(speed);
 

  if (ignition == true && digitalRead(18) == LOW) 
  { 
      detachInterrupt(digitalPinToInterrupt(vss_pin)); 
      detachInterrupt(digitalPinToInterrupt(LPG_pin));
      detachInterrupt(digitalPinToInterrupt(unleaded_pin));
      delay(50);
      ignition = false; 
      if (menunumber == 11) 
      {   
            EEPROM.writeByte(40, LPG1); //stores the new LPG coef.
            EEPROM.writeByte(41, LPG2);
            EEPROM.writeByte(42, LPG3);
            EEPROM.writeByte(43, LPG4);
         LPG_injector_flow = (LPG1 * 1000 + LPG2 * 100 + LPG3 * 10 + LPG4) * 1e-11; 
         inst_disp = true;
         tft.fillScreen(ST7735_BLACK);
         menunumber = 0; 
        
      }
      if (menunumber == 12) // same as previous for "Time Set" menu
      {
        DateTime dt = rtc.now();
        s = dt.second();
        if (m != m1) s = (((millis() - counter)/1000))%60; 
        else s = dt.second(), m = dt.minute(); 
        rtc.adjust(DateTime(dt.year(), dt.month(), dt.day(), h, m, s)); 
        ignoreRelease = true;
        lastButtonState2 = LOW;
        menunumber = 10;
        tft.fillScreen(ST7735_BLACK);
      }
      if (menunumber == 13) 
      {
            EEPROM.writeByte(50, un1); //stores the new unleaded coef.
            EEPROM.writeByte(51, un2);
            EEPROM.writeByte(52, un3);
            EEPROM.writeByte(53, un4);
        unleadedFlow = (un1 * 1000 + un2 * 100 + un3 * 10 + un4) * 1e-11; 
        inst_disp = true;
        tft.fillScreen(ST7735_BLACK);
        menunumber = 2;
      }
        if (menunumber == 14) 
      {
            EEPROM.writeByte(55, VSS1); //stores the new vss_pulse_distance  coef.
            EEPROM.writeByte(56, VSS2);
            EEPROM.writeByte(57, VSS3);
            EEPROM.writeByte(58, VSS4);
        vss_pulse_distance = (VSS1 * 1000 + VSS2 * 100 + VSS3 * 10 + VSS4) * 1e-7; 
        inst_disp = true;
        tft.fillScreen(ST7735_BLACK);
        menunumber = 3;
      }
      
      // when the ignition switched off it stores the values to the EEPROM
      EEPROM.writeFloat (0, traveled_distance);
      EEPROM.writeFloat (5, traveled_distance2);
      EEPROM.writeFloat (10, used_LPG);
      EEPROM.writeFloat (15, used_LPG2);
      EEPROM.writeFloat (20, Unleaded_in_tank);
      EEPROM.writeFloat (25, seconds_passed);
      EEPROM.writeFloat (30, used_Unleaded);
      EEPROM.writeFloat (35, traveled_distance3);
      EEPROM.writeFloat (45, used_Unleaded2);
      digitalWrite(24, HIGH); //podswietlenie 
      //display.ssd1306_command(SSD1306_DISPLAYOFF); 
      tft.sleep();
     
      tft.fillScreen(ST7735_BLACK);
      sleep_enable(); // enables the sleep mode
      set_sleep_mode(SLEEP_MODE_PWR_DOWN); // set the sleep mode
      cli();
      //sleep_bod_disable(); // disables the brown out detector to consume less power while sleeping
      sei();
      sleep_mode(); // microcontroller goes to sleep  
  }
  // when it wakes up continues from here -- also the first time we turn the ignition key to ON starts from here
  if (ignition == true && digitalRead(18) == HIGH) 
  { 
      
      digitalWrite(24, LOW);
      ignition = false;    // this variable is needed in order to run once the code inside this if
      logohold = millis(); // hold the LOGO screen on, for 2 sec
      inst_disp = true;
      
      //display.begin(SSD1306_SWITCHCAPVCC, 0x3C);           
      tft.wake();
      
      tft.fillScreen(ST7735_BLACK);                              
      tft.drawBitmap(30, 10,  logo, 104, 83, ST7735_RED);     
      delay(5000);
      tft.fillScreen(ST7735_BLACK);                                         

      attachInterrupt(digitalPinToInterrupt(vss_pin), distance, RISING); // attaches the interrupt which related to the VSS signal
      attachInterrupt(digitalPinToInterrupt(LPG_pin), LPG_injector_time, CHANGE); // interrupt for LPG injector signal
      attachInterrupt(digitalPinToInterrupt(unleaded_pin), UnleadedTime, CHANGE); // petrol injector signal input and interrupt 
      while (millis() - logohold < 2000) ; 
                                           

  }

    // every 5sec calculates average LPG consumption, remaining distance accordingly to the calculated remaining fuel in tank, average speed and average Unleaded cons.
  if(millis()%5000 < 50)
    {
    avg_LPG_consumption = 100 * used_LPG2/traveled_distance2; 
    distance_to_Unleadedstation = 100 * Unleaded_in_tank/average_L_100km_Unlead;   
    avg_speed = (traveled_distance3 / seconds_passed)*3600;           
    average_L_100km_Unlead = 100 * used_Unleaded2/traveled_distance2; 
    }

    
    

// For the short and long press function I consulted: http://jmsarduino.blogspot.gr/2009/05/click-for-press-and-hold-for-b.html
// There are many differences though
// "button 1" -- only  SHORT PRESS function -- changes occur on press, because there is no LONG PRESS function
    if (digitalRead(32) != buttonState) { 
      buttonState = digitalRead(32);      
      if (buttonState == LOW)             
      {                        
      if (menunumber <= menunumbermax){ // changes the display indications forwards
      if (menunumber == menunumbermax) menunumber =0;
      else menunumber += 1;
      tft.fillScreen(ST7735_BLACK);
      }
      if (menunumber == 12) //if we are at the "Time Set" menu it changes the Hour
      { 
        if (h < 23) h += 1, counter = millis();
        else h = 0, counter = millis();
      }
      // if we are at the "LPG Coef." menu it changes the LPG_injector_flow digits
        if (menunumber == 11 && digitLPG == 1){ 
          if (LPG1 < 9) LPG1 += 1, counter = millis();
          else LPG1 = 0, counter = millis();
        }
        if (menunumber == 11 && digitLPG == 2){ 
          if (LPG2 < 9) LPG2 += 1, counter = millis();
          else LPG2 = 0, counter = millis();
        }
        if (menunumber == 11 && digitLPG == 3){
          if (LPG3 < 9) LPG3 += 1, counter = millis();
          else LPG3 = 0, counter = millis();
        }
        if (menunumber == 11 && digitLPG == 4){
          if (LPG4 < 9) LPG4 += 1,  counter = millis();
          else LPG4 = 0, counter = millis();
        }
      // if we are at the "unleaded Coef." menu it changes the unleadedFlow digits
        if (menunumber == 13 && digitun == 1){ 
          if (un1 < 9) un1 += 1, counter = millis();
          else un1 = 0, counter = millis();
        }
        if (menunumber == 13 && digitun == 2){ 
          if (un2 < 9) un2 += 1, counter = millis();
          else un2 = 0, counter = millis();
        }
        if (menunumber == 13 && digitun == 3){
          if (un3 < 9) un3 += 1, counter = millis();
          else un3 = 0, counter = millis();
        }
        if (menunumber == 13 && digitun == 4){
          if (un4 < 9) un4 += 1,  counter = millis();
          else un4 = 0, counter = millis();
        }
      // if we are at the "Vss distance constant." menu it changes the vss_pulse_distance digits
        if (menunumber == 14 && digitVSS == 1){ 
          if (VSS1 < 9) VSS1 += 1, counter = millis();
          else VSS1 = 0, counter = millis();
        }
        if (menunumber == 14 && digitVSS == 2){ 
          if (VSS2 < 9) VSS2 += 1, counter = millis();
          else VSS2 = 0, counter = millis();
        }
        if (menunumber == 14 && digitVSS == 3){
          if (VSS3 < 9) VSS3 += 1, counter = millis();
          else VSS3 = 0, counter = millis();
        }
        if (menunumber == 14 && digitVSS == 4){
          if (VSS4 < 9) VSS4 += 1,  counter = millis();
          else VSS4 = 0, counter = millis();
        }
      
      }
    }

////////// "button 2" functions /////////////////
buttonState2 = digitalRead(34);
if (buttonState2 == LOW && lastButtonState2 == HIGH) lastDebounceTime = millis(); //keeps the time that button2 pressed

if (buttonState2 == HIGH && lastButtonState2 == LOW) 
{ 
if (ignoreRelease == false) // "button 2" SHORT PRESS functions -- on release
  { 
  if (menunumber <= menunumbermax) 
      {   if (menunumber == 0) menunumber = menunumbermax;
          else menunumber = menunumber - 1;
      tft.fillScreen(ST7735_BLACK);
      }
  if (menunumber == 12)  
      {  if (m < 59) m=m+1, counter = millis();
         else m = 0, counter = millis();
      
      }
  if (menunumber == 11) // LPG coef. setting menu -- "button 2" short press changes the position of the cursor
      { pos += 20; 
        digitLPG += 1;
        counter = millis();
        if (digitLPG == 5)
          { pos = 20;
            digitLPG = 1;
          }
      }
  if (menunumber == 13) // unleaded Coef. setting menu -- "button 2" short press changes the position of the cursor
      { posi += 20; 
        digitun += 1;
        counter = millis();
        if (digitun == 5)
          { posi = 20;
            digitun = 1;
          }
       }
  if (menunumber == 14) // vss_pulse_distance. setting menu -- "button 2" short press changes the position of the cursor
      { posit += 20; 
        digitVSS += 1;
        counter = millis();
        if (digitVSS == 5)
          { posit = 20;
            digitVSS = 1;
          }
      }
  }
else ignoreRelease = false;
}
//////////////////// "button 2" LONG PRESS functions /////////////////////////////////////////////////////
if (digitalRead(34) == HIGH) displaychange = true;   
if (buttonState2 == LOW && (millis() - lastDebounceTime) > 3000 && displaychange == true) // below are the long press functions for button 2
{
      if (menunumber == 0) menunumber = 11, counter = millis(), counter2 = millis(), displaychange = false, digitLPG = 1,  tft.fillScreen(ST7735_BLACK); //goes to the "LPG Coef." menu
      if (menunumber == 1) menunumber = 13, counter = millis(), counter2 = millis(), displaychange = false, digitun = 1,   tft.fillScreen(ST7735_BLACK);  //goes to the "vss_pulse_distance." menu//traveled_distance2 = 0, used_LPG2 = 0, avg_LPG_consumption = 0, used_Unleaded2 = 0,  tft.fillScreen(ST7735_BLACK);// average LPG consumption and average Unleaeded cons. reset
      if (menunumber == 2) menunumber = 14, counter = millis(), counter2 = millis(), displaychange = false, digitVSS = 1,  tft.fillScreen(ST7735_BLACK); //goes to the "Unleaded Coef." menu
      if (menunumber == 3) traveled_distance3 = 0, seconds_passed = 0, avg_speed = 0,  tft.fillScreen(ST7735_BLACK); // average speed reset
      if (menunumber == 4) traveled_distance = 0,  tft.fillScreen(ST7735_BLACK); //traveled Distance = 0
      if (menunumber == 6) used_LPG = 0,  tft.fillScreen(ST7735_BLACK); // total LPG litres = 0
      if (menunumber == 7) Unleaded_in_tank = Full_tank,  tft.fillScreen(ST7735_BLACK); // LPG tank reset to full
      if (menunumber == 8) used_Unleaded = 0,  tft.fillScreen(ST7735_BLACK); // total unleaded fuel reset
      if (menunumber == 9) traveled_distance2 = 0, used_LPG2 = 0, avg_LPG_consumption = 0, used_Unleaded2 = 0,  tft.fillScreen(ST7735_BLACK); // same with menunumber = 1
      if (menunumber == 10) menunumber = 12, counter = millis(), counter2 = millis(), timeRead = true, displaychange = false,  tft.fillScreen(ST7735_BLACK); //goes to the "Time Setting" menu
  
ignoreRelease = true; 
}
lastButtonState2 = buttonState2;
//// speed 
  //SpeedTime = SpeedTime+(SpeedTime2-SpeedTime1); //total useconds that the gasoline injector opens throughout 1sec                                                                                
  //speed = (SpeedTime* vss_pulse_distance  * 1);  
  








// below are the misc screens
switch (menunumber) 
{
    case 0: 
    cons0:  
       
        if(inst_disp == true) displaychange = false, inst_disp = false, digitLPG = 0, pos = 20; 
        tft.setTextColor(ST7735_GREEN,     ST7735_BLACK);
        //tft.drawBitmap(20, 20,  petrolstationpump, 32, 32, ST7735_BLUE);
        //tft.setCursor(60, 30);
        //tft.setTextSize(1);
        //tft.print(F("LPG"));
        tft.setCursor(58,35);
        tft.setTextSize(1);
        if (speed > 2) 
        {tft.print(F("L/ "));
         tft.setCursor(58,43);
         tft.setTextSize(1);
         tft.print(F("100"));}
        else tft.print(F("L/H")); //when the car is stopped displays the instant consumption in l/h
        tft.setCursor(10,36);
        tft.setTextSize(2);
        if(instant_unlead_consumption > 99.9) tft.print(F("99.9"));
        else tft.print(instant_unlead_consumption  , 1);
        
        tft.setCursor(10,63);
        tft.setTextSize(2.5);
        if (speed > 2){ 
          if(average_L_100km_Unlead > 99.9) tft.print(F("99.9"));
          else tft.print(average_L_100km_Unlead  , 1);}
        else
        tft.print(used_Unleaded  , 1);
        tft.print(" ");
        tft.setCursor(58,60);
        tft.setTextSize(1);
        tft.print(F("L/"));
        tft.setCursor(58,70);
        tft.setTextSize(1);
        tft.print(F("100"));
        
        tft.drawFastHLine(0, 55, 168, ST7735_GREEN);
        
        tft.setCursor(80,36);
        tft.setTextSize(2.5);
        tft.print(speed, 0);
        tft.print("  ");
        tft.setCursor(125,42);
        tft.setTextSize(1);
        tft.print(F("km/h"));
        
        
        tft.setCursor(80,63);
        tft.setTextSize(2.5);
        tft.print(traveled_distance, 1);
        tft.setCursor(125,70);
        tft.setTextSize(1);
        tft.print(F("km"));
       
    break;

    case 1: 
       cons1:
        if(inst_disp == true) displaychange = false, inst_disp = false, digitun = 0, posi = 20; 
        tft.setTextColor(ST7735_GREEN , ST7735_BLACK);
        tft.drawBitmap(20, 25,  averagecons, 64, 32, ST7735_GREEN); 
        tft.setCursor(54, 10);
        tft.setTextSize(1);
        tft.print(F("LPG"));
        tft.setCursor(74,30);
        tft.setTextSize(1);
        tft.print(F("L/100"));
        tft.setCursor(40, 60);
        tft.setTextSize(3);
        //if(isnan(average_L_100km_Unlead)|| isinf(average_L_100km_Unlead)) tft.println(F("---")); 
        //else tft.println(average_L_100km_Unlead, 1);
        if(instant_unlead_consumption > 99.9) tft.print(F("99.9"));
        else tft.print(instant_unlead_consumption  , 2);
        tft.print("  ");
    break;
    

    case 2: 
        if(inst_disp == true) displaychange = false, inst_disp = false, digitVSS = 0, posi = 20; 
        tft.setTextColor(ST7735_GREEN, ST7735_BLACK);
        tft.drawBitmap(60, 25,  speedometer, 32, 32, ST7735_GREEN);
        tft.setCursor(30,56);
        tft.setTextSize(4);
        tft.print(speed , 1);
        tft.print("   ");
        //tft.setCursor(98, 54);
        //tft.setTextSize(2);
        //tft.print(F("km"));
        //tft.setCursor(124, 60);
        //tft.setTextSize(3);
        //tft.print(F("/"));
        //tft.setCursor(135, 72);
        //tft.setTextSize(2);
        //tft.print(F("h"));
        
    break;
    
    case 3:  
        
        tft.setTextColor(ST7735_GREEN, ST7735_BLACK);
        tft.drawBitmap(31, 25,  avspeed, 64, 32, ST7735_GREEN);
        tft.setCursor(10, 56);
        tft.setTextSize(4);
        tft.print(avg_speed, 0);
        tft.print("  ");
        tft.setCursor(94, 54);
        tft.setTextSize(2);
        tft.print(F("km"));
        tft.setCursor(118, 57);
        tft.setTextSize(3);
        tft.print(F("/"));
        tft.setCursor(130, 68);
        tft.setTextSize(2);
        tft.print(F("h"));
       
    break;
      
    case 4:          
        
        tft.setTextColor(ST7735_GREEN, ST7735_BLACK);
        tft.drawBitmap(58, 20,  dist, 32, 32, ST7735_GREEN); 
        tft.setCursor(98,38);
        tft.setTextSize(2);
        tft.print(F("km"));
        tft.setCursor(30, 56);
        tft.setTextSize(4);
        tft.print(traveled_distance, 2);
        
    break;
      
    case 5:  
        
        tft.setTextColor(ST7735_RED, ST7735_BLACK);
        tft.drawBitmap(20, 25,  dist_to_LPG, 128, 32, ST7735_RED); 
        tft.setCursor(20, 56);
        tft.setTextSize(4);
        if(distance_to_Unleadedstation < 10 ||  isnan(distance_to_Unleadedstation) || isinf(distance_to_Unleadedstation) ) tft.println(F("---"));
        else tft.print(distance_to_Unleadedstation,0);
        tft.setTextSize(2);
        tft.setCursor(120,68);
        tft.print(F("km"));
        
    break;
      
    case 6:
       
        tft.setTextColor(ST7735_WHITE, ST7735_BLACK);
        tft.drawBitmap(30, 30,  leaf, 32, 32, ST7735_WHITE); 
        tft.setCursor(70, 32);
        tft.setTextSize(1);
        tft.print(F("Total"));
        tft.setCursor(70, 42);
        tft.setTextSize(2);
        tft.print(F("LPG"));
        tft.setCursor(30, 66);
        tft.setTextSize(2);
        tft.print(used_LPG,1);
        tft.print(F("L"));
        
    break;

    case 7: 
        
        tft.setTextColor(ST7735_GREEN, ST7735_BLACK);
        tft.drawBitmap(45, 25,  FuelTank, 64, 32, ST7735_YELLOW); 
        tft.setCursor(30, 60);
        tft.setTextSize(3);
        if (Unleaded_in_tank <= 0 ) tft.print(F("0.0"));
        else tft.print(Unleaded_in_tank,2);
        tft.setTextSize(3);
        tft.setCursor(125,60);
        tft.print(F("L"));
      
    break;

    case 8: 
 
        
   tft.setTextColor(ST7735_GREEN, ST7735_BLACK);
        tft.drawBitmap(96, 30,  Unleaded_fill_nozzle, 32, 32, ST7735_GREEN); //(x,y, name, DX, DY, color)
        tft.setTextSize(1);
        tft.setCursor(20, 40);
        tft.println(F("Total"));
        tft.setTextSize(1);
        tft.setCursor(20, 30);
        tft.println(F("Unleaded"));
        tft.setCursor(40, 63);
        tft.setTextSize(3);
         if(used_Unleaded > 999.9) tft.print(F("999.9"));
        else tft.print(used_Unleaded  , 2);
         
        tft.setTextSize(3);
        tft.setCursor(125,63);
        tft.println(F("L"));
    
    break;
    
    case 9: 
        
        tft.setTextColor(ST7735_GREEN, ST7735_BLACK);
        tft.drawBitmap(20, 38,  average, 16, 16, ST7735_GREEN);
        tft.drawBitmap(37, 30,  Unleaded_fill_nozzle, 32, 32, ST7735_GREEN); 
        tft.setCursor(84,33);
        tft.setTextSize(2);
        tft.println(F("l/100"));
        tft.setCursor(20, 56);
        tft.setTextSize(4);
        //if(isnan(average_L_100km_Unlead)|| isinf(average_L_100km_Unlead)) tft.println(F("---"));
        //else tft.println(average_L_100km_Unlead, 1);
        if(average_L_100km_Unlead > 99.9) tft.print(F("99.9"));
        else tft.print(average_L_100km_Unlead  , 1);
    break;

    case 10: 
        
       temp1:     if(inst_disp == true) displaychange = false, inst_disp = false;
            
            tft.setTextColor(ST7735_GREEN, ST7735_BLACK);
            
            printTemperature();
            tft.drawFastHLine(0, 48, 168, ST7735_GREEN);
            tft.drawFastHLine(0, 49, 168, ST7735_GREEN);
            tft.drawFastHLine(0, 50, 168, ST7735_GREEN);
            tft.setCursor(30, 56);
            tft.setTextSize(3);
            printTime();
          if(sensors.getTempCByIndex(0) < 3.5)
          {
          tft.drawBitmap(0, 3,  snowflake, 16, 16, ST7735_WHITE); 
          }
        
      break;
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// the following are secondary displays and activated only in case we want to set the LPG Coef.(case 11) or the Time (case 12) 
      
    case 11: // LPG Coef. Setting menu
        
        tft.setTextColor(ST7735_WHITE, ST7735_BLACK);
        tft.setCursor(20,39);
        tft.setTextSize(2);
        tft.println(F("LPG Coef."));
        tft.drawFastHLine(15, 28, 128, ST7735_WHITE);
        tft.drawFastHLine(15, 29, 128, ST7735_WHITE);
        
        tft.setCursor(20,66);
        tft.setTextSize(2);
        tft.println(LPG1);
          tft.setCursor(40,66);
        tft.println(LPG2);
          tft.setCursor(60,66);
        tft.println(LPG3);
          tft.setCursor(80,66);
        tft.println(LPG4);
       
        tft.setCursor(pos,70);
        tft.println(F("_")); 
        if (digitalRead(34) == HIGH) counter2 = millis(), displaychange = true; //we must release "button 2" at least once in order to be able to go back to instant LPG consuption
        if ((digitalRead(34) == LOW && millis() - counter2 > 3000 && displaychange == true) || millis() - counter > 10000){ 
            EEPROM.writeByte(40, LPG1); //stores the new LPG coef.
            EEPROM.writeByte(41, LPG2);
            EEPROM.writeByte(42, LPG3);
            EEPROM.writeByte(43, LPG4);
         LPG_injector_flow = (LPG1 * 1000 + LPG2 * 100 + LPG3 * 10 + LPG4) * 1e-11; 
         ignoreRelease = true; 
         inst_disp = true;
         lastButtonState2 = LOW;
         tft.fillScreen(ST7735_BLACK);
         menunumber = 0;  
         goto cons0;       
        }
        
    break;

    case 12: //RTC set
      
        tft.setTextColor(ST7735_WHITE, ST7735_BLACK);
        tft.setCursor(30,30);
        tft.setTextSize(2);
        tft.print(F("Time Set"));
        tft.drawFastHLine(15, 48, 128, ST7735_WHITE);
        tft.drawFastHLine(15, 49, 128, ST7735_WHITE);

        if (timeRead == true){ 
        DateTime dt = rtc.now();
        h = dt.hour();
        m = dt.minute();
        m1 = dt.minute(); 
        timeRead = false;
        }
        tft.setCursor(47, 66);
        tft.setTextSize(2);
        char sdt[15];
        sprintf(sdt, "%02d:%02d", h, m);
        tft.print(sdt); 
        
        
        if(digitalRead(34) == HIGH) counter2 = millis(), displaychange = true; //we must release the button 2 at least once in order to be able to go back to Temp and Time screen
        if((digitalRead(34) == LOW && millis() - counter2 > 3000 && displaychange == true) || millis() - counter > 59000){
        DateTime dt = rtc.now();
        s = dt.second();
        if (m != m1) s = (((millis() - counter)/1000))%60; 
        else s = dt.second(), m = dt.minute(); 
        rtc.adjust(DateTime(dt.year(), dt.month(), dt.day(), h, m, s)); 
        inst_disp = true;
        ignoreRelease = true;
        lastButtonState2 = LOW;
        menunumber = 10;
        }
    break;
     
     case 13:  //Unleaded coeficient
       
        tft.setTextColor(ST7735_WHITE, ST7735_BLACK);
        tft.setCursor(15,40);
        tft.setTextSize(2);
        tft.println(F("Unleaded Coef."));
        tft.drawFastHLine(15, 26, 128, ST7735_WHITE);
        tft.drawFastHLine(15, 27, 128, ST7735_WHITE);
        tft.setCursor(20,66);
        tft.setTextSize(2);

        tft.println(un1);
          tft.setCursor(40,66);
        tft.println(un2);
          tft.setCursor(60,66);
        tft.println(un3);
          tft.setCursor(80,66);
        tft.println(un4);
        tft.setCursor(posi,70);
        tft.println(F("_")); 
        tft.println(F("  ")); 
        if(digitalRead(34) == HIGH) counter2 = millis(), displaychange = true; //we must release the button 2 at least once in order to be able to go back to Temp and Time screen
        if((digitalRead(34) == LOW && millis() - counter2 > 3000 && displaychange == true) || millis() - counter > 10000){
            EEPROM.writeByte(50, un1); //stores the new Unlead coef.
            EEPROM.writeByte(51, un2);
            EEPROM.writeByte(52, un3);
            EEPROM.writeByte(53, un4);
        unleadedFlow = (un1 * 1000 + un2 * 100 + un3 * 10 + un4) * 1e-11; //unleded coeficent
        inst_disp = true;
        ignoreRelease = true; 
        lastButtonState2 = LOW;
        tft.fillScreen(ST7735_BLACK);
        menunumber = 1;  
        }
       break;
      
      case 14: // vss_pulse_distance. Setting menu
        
        tft.setTextColor(ST7735_WHITE, ST7735_BLACK);
        tft.setCursor(20,39);
        tft.setTextSize(2);
        tft.println(F("vss_pulse_distance"));
        tft.drawFastHLine(15, 28, 128, ST7735_WHITE);
        tft.drawFastHLine(15, 29, 128, ST7735_WHITE);
        
        tft.setCursor(20,66);
        tft.setTextSize(2);
        tft.println(VSS1);
          tft.setCursor(40,66);
        tft.println(VSS2);
          tft.setCursor(60,66);
        tft.println(VSS3);
          tft.setCursor(80,66);
        tft.println(VSS4);
       
        tft.setCursor(posit,70);
        tft.println(F("_")); 
        if (digitalRead(34) == HIGH) counter2 = millis(), displaychange = true; //we must release "button 2" at least once in order to be able to go back to instant LPG consuption
        if ((digitalRead(34) == LOW && millis() - counter2 > 3000 && displaychange == true) || millis() - counter > 10000){ 
            EEPROM.writeByte(55, VSS1); //stores the new VSS coef.
            EEPROM.writeByte(56, VSS2);
            EEPROM.writeByte(57, VSS3);
            EEPROM.writeByte(58, VSS4);
         vss_pulse_distance = (VSS1 * 1000 + VSS2 * 100 + VSS3 * 10 + VSS4) * 1e-7; 
         ignoreRelease = true; 
         inst_disp = true;
         lastButtonState2 = LOW;
         tft.fillScreen(ST7735_BLACK);
         menunumber = 2;  
         //goto cons1;      
        }
        
    break;
      }
  }

ISR(TIMER1_COMPA_vect) //TIMER1 overflow interrupt -- occurs every 1sec -- 
{
    
    
    LPG_Consumption();
    LPG_injector_open_duration = 0;
    
    ///unleadedConsumption();
    //unleadinj_Open_Duration = 0;
   
    seconds_passed++;
    
    unsigned long time = millis();
    unsigned long dt = time - last_speed_calculation_time;
    if (dt > 2000) { //brak impulsow przez 2s oznacza ze stoimy
    speed = 0;
    last_speed_calculation_time = time; //to jest potrzebne żeby jak przestaniemy stac - od razu liczylo predkosc dla okresu po zatrzymaniu, a nie dla calego czasu zatrzymania
}

}

void distance()
{
  unsigned long time = millis();
  vss_pulses++;
  traveled_distance += vss_pulse_distance;  
  traveled_distance2 += vss_pulse_distance; 
  traveled_distance3 += vss_pulse_distance; 
                                            // we calculate 3 times the same thing in order to reset the distance, the average cons. and average speed independently
  unsigned long dt = time - last_speed_calculation_time;                  
  if (dt >= 1000) {
      instantSpeed(dt);
    last_speed_calculation_time = time;
  }
}

void instantSpeed(unsigned int dt) 
{
  speed = (vss_pulse_distance * vss_pulses * 3600 * 1000 / dt); 
  vss_pulses = 0;
}

// The following routine is giving the way to calculate the total time that LPG injector open during the 1sec interval
void LPG_injector_time() 
{ 
  injTime2 = micros();
    if ((injTime2 - injTime1)<5000 && (injTime2 - injTime1)> 4) 
    {
    LPG_injector_open_duration = LPG_injector_open_duration + injTime2 - injTime1; 
    }   
  injTime1 = injTime2;
}


void LPG_Consumption()
{
if (speed > 2 ) instant_LPG_consumption = (100*((LPG_injector_open_duration * LPG_injector_flow)*3600))/speed; 
                                                                                                       
else  instant_LPG_consumption = LPG_injector_open_duration * LPG_injector_flow * 3600; // when the car stops calculates the instant consumption in l/h

used_LPG = used_LPG + (LPG_injector_open_duration * LPG_injector_flow);       
used_LPG2 = used_LPG2 + (LPG_injector_open_duration * LPG_injector_flow);     
//LPG_in_tank = LPG_in_tank - (LPG_injector_open_duration * LPG_injector_flow); 
}

void UnleadedTime() // it is called every time a change occurs at the gasoline injector signal and calculates gasoline injector opening time, during the 1sec interval
{
  unsigned long time = millis();
  
  if (digitalRead(19) == LOW)
      {
        unleadTime1 = micros();
      }
  if (digitalRead(19) == HIGH)
      {
        unleadTime2 = micros();
      }
  if (unleadTime2 > unleadTime1)
      {
         if ((unleadTime2 - unleadTime1) > 500 && (unleadTime2 - unleadTime1) < 12000) // some conditions to avoid false readings because of noise 
         { 
            unleadinj_Open_Duration = unleadinj_Open_Duration + (unleadTime2 - unleadTime1); //total useconds that the gasoline injector opens throughout 1sec                                                                                
         } 
      
         unsigned long dt1 = time - last_fuel_calculation_time;                  
         if (dt1 >= 1000)
         {
            unleadedConsumption(dt1);
            last_fuel_calculation_time = time;
         }
      }
}

void unleadedConsumption(unsigned int dt1)
{
  if (speed > 2 ) instant_unlead_consumption = (100*((unleadinj_Open_Duration * unleadedFlow)*3600* 1000 / dt1))/speed; 
                                                                                                       
  else  instant_unlead_consumption = unleadinj_Open_Duration * unleadedFlow * 3600 * 1000 / dt1 ; // when the car stops calculates the instant consumption in l/h
  
  
  used_Unleaded = used_Unleaded + (unleadinj_Open_Duration * unleadedFlow);   
  used_Unleaded2 = used_Unleaded2 + (unleadinj_Open_Duration * unleadedFlow); 
  Unleaded_in_tank = Unleaded_in_tank - (unleadinj_Open_Duration * unleadedFlow); 
  
  unleadinj_Open_Duration = 0;
}


void ignitionSignal() // this is called everytime the ingintion signal changes -- if the microcontroller is in sleep mode, it will wake up
{
    ignition = !ignition;
}

void printTime() 
{
  DateTime dt = rtc.now();
  char sdt[15]; 
  sprintf(sdt, "%02d:%02d", dt.hour(), dt.minute()); 
  tft.println(sdt);          
}

void printTemperature() 
{
  
        // call sensors.requestTemperatures() to issue a global temperature 
 // request to all devices on the bus 
/********************************************************************/
 
 sensors.requestTemperatures(); // Send the command to get temperature readings  
 //Serial.print(sensors.getTempCByIndex(0)); // Why "byIndex"?  
 //delay(1000); 
        
        //if (sensors.getTempCByIndex(0) <0 && sensors.getTempCByIndex(0) > -0.6)
        //if(sensors.getTempCByIndex(0) >= 9.5 || (sensors.getTempCByIndex(0) <= -0.6 && sensors.getTempCByIndex(0) > -9.6)) postemp = 62; //postemp: the x position of the cursor is depended on how many characters the temp has (1, 2 or 3)
        //if(sensors.getTempCByIndex(0) < 9.5 && sensors.getTempCByIndex(0) > -0.6) postemp = 80;
        //if(sensors.getTempCByIndex(0) <= -9.6) postemp = 44;
        
        tft.setCursor(90,30);
        tft.setTextSize(2);
        tft.println(sensors.getTempCByIndex(0), 0);
        tft.setCursor(120, 28);
        tft.setTextSize(1);
        tft.println(F("o"));
        tft.setCursor(128, 30);
        tft.setTextSize(2);
        tft.println(F("C"));

        tft.setCursor(20,30);
        tft.setTextSize(2);
        tft.println(sensors.getTempCByIndex(1), 0);
        tft.setCursor(50, 28);
        tft.setTextSize(1);
        tft.println(F("o"));
        tft.setCursor(58, 30);
        tft.setTextSize(2);
        tft.println(F("C"));
   

}
